// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}func u
protocol a {
typealias e
func e{
[ 1
}}class p{}struct f: A
let : A {
}typealias b()
f{func b:a : Int = ()
let h:a
}}class A{
" [ 1
let a=b:a{
}
typealias e:a<T where h:b:a<d{
struct B<T where B : a {
let a{
class a
var _=Void{func e(
class a {func j
struct c<T where B : a class k:a{
let e = B<func h:a {
func j,f: P {let i: a }struct c<d {
class B{
protocol P{
}
let a<d {
class B<d
let i: P {
var _=Void{}
class b(e?)")
protocol a {
(A
}
class B<d {func u
class b:a }struct c<d {}
protocol B<d<D> : a{
class c
class k:e{{func u
let a=b
struct A{
enum e
enum e
vs dwhere S
class c
let a{func e{
class A{
f{
var _=b:e){
sct S
struct f{
class B<T where B : Int = () {
protocol a=Void{}
class k:a
{}
}}
let h:a {
}
}struct c<T where B : P {func u
func u(e
let a{typealias e)
protocol P
var : C {
" [ ]
{
func b}}}struct B<T where B : Int = ()
var : P {{
}}struct f{
typealias e:a
struct c()
class b}}typealias b(e{func h
var f = B<T where B : A
let a
class c() {
struct B<T where B : a : b(")
struct c
protocol P
let : a }
let d
}
enum e{func j
let a{
}struct c<T where B : A{
class d {
class A{}
let h:a {
let e = B<T where B : a }struct d{typealias e{
struct A
[ ]
protocol A{
class B<T where B : Int = () {
let a
}
{
[ ]
[ ]
[ 1
struct B<T where B : b:b() {let d{
f<T where h:e(){}}
func b()
protocol A{
}
}struct A{
[ 1
struct c(
struct f: a }
let a{
class a class a{
protocol B<D> : A{func u(e
let f = 4
()
let a {
func u
vs dwhere S< >() {
class b
vs dwhere S
protocol a {
func u()
}
sct S< >(A
struct c
class d {
class d {
}
struct c(e{
protocol a {
struct B{
}}
}
var _=b() {
struct c<T where B : A {}
}}
struct f: a : a {
sct S< >(A
let i: a {
let e = (e)
class A
struct B<T where B : a {
class d {}
sct S< >()
var _=b}
struct d<T{
class B<T where B : a }
class c<T where B : P {
let d
let a : b(e()")
class p{
func b:a
vs dwhere S< >(
f: a {let a{
func j
class c<D> : a }struct c<T where h:a {
var f = (e)
class d {
f: A {
f<D> : a:a
func b:a<T : C {}class b( ) {
let a {
let i: P {
typealias e{
}
enum e
let a class a
class a<d {
class a class B<d<D> : a {
