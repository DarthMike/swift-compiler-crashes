// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

enum S<T where T=[Void{
struct d{
let f
}struct d{
}
f
let:d:T=[Void{
protocol c {
class A{struct b{
struct b{
func x(a<T where k
class d=a{
if true{
class A{
f<T where H:CollectionType
let:SequenceType
class B<k:SequenceType
class A{
<T where f=a{
b : a: A : A{
let a{typealias d{
struct d
var _ = []
f: a:{
}
struct d{
}
func a<T where H:T{
class B{
var a{typealias d:d where T=k:d where j: A{
}
f:{}
var _=[Void{
class A {
}}
protocol c
func x(a{
let:a{
func a{
if true{
class
struct B<T where f
struct d B {
struct Q<T where I : P {
class B<d { }
}
func a{enum S<T where j: P {
}}
struct i<T where f:{let a{
{
protocol A {let a
let f=c
protocol a=c
}
}}
}
class B<
class A{
}}}
class d=c{
}
}struct B{
class
func a
protocol a
var b {
var a{
l
func a{
}
<d where I : P {}
class B<T where I : a{
let a{struct B{let c{
func a?{
protocol c<k
struct c<A{
}
}
class d{
f
let:{enum S<T where d:CollectionType
enum S
class A
class a: a:a:NSObject
func x(a{
f=B:{
class A{
}func f {
class b:CollectionType
protocol c {
{
}
}
struct S<T>
}func x(a{
protocol c{func a{
class C<T where f<T where f<T where H:NSObject
struct d where h:NSObject
class A {
class B<d { }
class
l
struct B
}}
class A{
class C<T where H:a
var _=c<T>
}
func a{
{
let f<T where f: A {
}class C<T where k:d B {}struct B{
struct S<T where h:NSObject
let:a<
let:a{
class b:
func a{
class C<S<T where d{
}protocol c<T where T{struct c{
func x(a{let f:{
struct c
class A{
struct d B {
let f=c<T where I : A : A{
}
{
f
l
let a<
struct d:a{
struct d B {
class a{class a=k
}
f:{
struct d
class a{
class A{struct c<T where H:{let f=[]
class A{
class a{
var f
class d=k>i<T where h:a{
struct B{
struct Q<T where B<T>
var a{
struct B{struct c
func f {typealias d:
b {
class d:CollectionType
class d{
struct c{
struct B{
func a{
{
}
class B<k>->i<S
struct B{}
func a{
"
protocol c<T where j: a: A
func a(a{
{
class a
class b{
class B{struct Q<d { }
class d:a<T where H:d { }
struct Q<T where j: A {}protocol c
class B<T where h:a{
struct B{
class A
class A
protocol c
struct B
}
let:
class
struct b:T{
class A {
{
var
class A
enum e{
class d
class C<T=a{enum S<T where j: Poid{typealias d=a: A : A : a{
func a=c
}
