// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

class d{
enum S<T {
let c : A.b: T
}
}struct c,
struct A {
class A {
enum B : NSManagedObject {
class A {
class a {
enum S<h : A: a
class A.dynamicType)
class a
class a
enum S<T where H.B : T
class d{
switch x }
{
}
}
}
func b
struct A {
return "[1)"[1)?
switch x }
class A.dynamicType)"[1)
class d
}
func a
let a = "[1)
class A {
struct A : Array) {
func b<h : Any, A{
class b
if true {
case
{
struct B
class func a{{
class func a<U : String = ""[1)"\(e: T
struct A {
}
struct D : Any, A.dynamicType)"[1)"\(e: Any, x }}
var f = compose<h: T
class a = compose<h : T
struct c<d where S<T {func g<h : d{
struct D : T
class A : d{
struct D : Array) {
struct S<T:A: a {
case c>
}struct S<T where T
class B
class B<T
switch x in 0
class func a<S : a{
enum S<T where H:i{
class
let a = compose<d where A? {
enum S<T
{
let f=a
}
var f = compose<T
class a {
}
}
enum S<c>: AnyObject.Generator
return "\(e: T
}
{
class c>
let c : Array) {
let a = "[1)
}
struct S<T where S<T
enum S<T where H.Generator
protocol A: T: d = nil
class b
class d
func g{
enum S<T
let a {
class B<T where f=b: d
struct D : String = nil
let end = compose<U : AnyObject, A.b
}
class a {
protocol A.b: d
func a<T: a = compose<T {extension g<T:a{
}
}
struct c>
var f = "\(e: a<T> : Any, A.dynamicType)"\(e:d func a
enum S:A
struct D : d
struct A class a
class a<h : a<f
let a = "
func b{
class B<T where H.b
struct c : d
func a
func g<T>
protocol a {
class a {
func a
var f
let c {
struct d where h: NSManagedObject {
let c : String = compose<h: String = 0.Generator
protocol A {
func a
let c : T
enum S:var f=a<h: T:A
class a = ""[1)
if true {
class b<h: a
protocol A : String = compose<T where h: a
}
protocol A.dynamicType)
func a
class
struct D : NSManagedObject {
enum S<T {
protocol A : d{
{func g<T where H.B {
let f=a<T where A.dynamicType)"[1)
class A.b: Any, A: AnyObject.b
{
struct c<T
{
enum B : d
enum S<T where h: Any, A: a {func a<T where f=a{
class A : T>
func a
protocol f = compose<T where h: d = nil
struct A : String = T:r
func A.b{
struct D : String = compose<T {
{func b<T where H.b:e: String = 0
class a = "[1)
class A : A
class a = T:var f = "[1)""\(e
class d
struct D : T>: T: Any, A{
class func a{
protocol A : d<h : a {
protocol A {
let a
class A{
let a {var f = compose<T
class d
func b: Array) {
func d<T where T: T
